{
  "usecase": {
    "name": "Regex Pattern Generation from Examples",
    "folder": "sample-usecases/03-regex-generation",
    "data_file": "sample-usecases\\03-regex-generation\\data\\regex-challenges.json",
    "ground_truth_file": "sample-usecases\\03-regex-generation\\ground-truth\\regex-solutions.json"
  },
  "prompts": {
    "analysis": {
      "transformation_type": "Pattern recognition and regex generation - the LLM must analyze positive and negative string examples to infer the underlying pattern and express it as a valid regular expression",
      "key_fields": [
        "challenge_id",
        "regex",
        "explanation",
        "confidence",
        "test_results"
      ],
      "quality_indicators": [
        "Regex matches ALL positive examples (100% recall on training set)",
        "Regex rejects ALL negative examples (100% precision on training set)",
        "Regex generalizes to held-out test cases not shown to model",
        "Regex is syntactically valid and executable",
        "Regex is reasonably concise (not just OR-ing all examples)",
        "Explanation accurately describes what the pattern matches"
      ],
      "comparison_strategy": "Execute the generated regex against all positive/negative examples (both provided and held-out). Calculate match rates. Validate syntax. Compare regex complexity. Check for overfitting patterns like excessive alternation."
    },
    "task_prompt": "You are a regex pattern generation expert. Your task is to analyze sets of positive and negative string examples and generate a regular expression that correctly matches the pattern.\n\n# INSTRUCTIONS\n\n1. Carefully examine the positive examples to identify what they have in common\n2. Examine the negative examples to understand what should NOT match\n3. Generate a regular expression that:\n   - Matches ALL positive examples\n   - Rejects ALL negative examples\n   - Is concise and generalizable (avoid overfitting)\n   - Uses standard regex syntax (PCRE or JavaScript compatible)\n4. Include anchors (^ and $) to match the entire string\n5. Provide a clear explanation of what your pattern matches\n6. Test your regex mentally against all examples before finalizing\n\n# INPUT FORMAT\n\nYou will receive a challenge with:\n- `challenge_id`: Unique identifier\n- `name`: Description of the pattern type\n- `difficulty`: Complexity level\n- `positive_examples`: Strings that MUST match your regex\n- `negative_examples`: Strings that must NOT match your regex\n- `hint`: Optional guidance about the pattern\n\n# OUTPUT FORMAT\n\nRespond with valid JSON matching this exact schema:\n\n```json\n{\n  \"challenge_id\": \"REGEX-XXX\",\n  \"regex\": \"^your_pattern_here$\",\n  \"explanation\": \"Clear description of what the pattern matches and key constraints\",\n  \"confidence\": \"high|medium|low\",\n  \"test_results\": {\n    \"positive_matches\": <number of positive examples your regex matches>,\n    \"positive_total\": <total positive examples>,\n    \"negative_rejected\": <number of negative examples your regex correctly rejects>,\n    \"negative_total\": <total negative examples>\n  }\n}\n```\n\n# IMPORTANT GUIDELINES\n\n- Your regex should generalize beyond the specific examples (think about the underlying rule)\n- Avoid simply OR-ing all positive examples together\n- Consider edge cases and boundary conditions\n- Use character classes, quantifiers, and grouping appropriately\n- Escape special regex characters properly\n- Test your regex against ALL provided examples\n- Set confidence based on pattern complexity and your certainty\n\n# EXAMPLE\n\nInput:\n```json\n{\n  \"challenge_id\": \"REGEX-001\",\n  \"positive_examples\": [\"555-123-4567\", \"123-456-7890\"],\n  \"negative_examples\": [\"55-123-4567\", \"555.123.4567\"]\n}\n```\n\nOutput:\n```json\n{\n  \"challenge_id\": \"REGEX-001\",\n  \"regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n  \"explanation\": \"Three digits, dash, three digits, dash, four digits - standard US phone format\",\n  \"confidence\": \"high\",\n  \"test_results\": {\n    \"positive_matches\": 2,\n    \"positive_total\": 2,\n    \"negative_rejected\": 2,\n    \"negative_total\": 2\n  }\n}\n```\n\nNow process the challenge and generate your regex pattern.",
    "judge_prompt": "You are evaluating a regex pattern generation task. The model was given positive and negative string examples and asked to generate a regular expression that matches all positive examples and rejects all negative examples.\n\n# EVALUATION CRITERIA\n\n## 1. CORRECTNESS ON PROVIDED EXAMPLES (40 points)\n\n**Test the regex against all provided examples:**\n- Execute the regex against each positive example\n- Execute the regex against each negative example\n- Calculate match rates\n\n**Scoring:**\n- Perfect match (100% positive matched, 100% negative rejected): 40 points\n- For each positive example that fails to match: -4 points\n- For each negative example that incorrectly matches: -4 points\n- Minimum: 0 points\n\n## 2. GENERALIZATION TO HELD-OUT EXAMPLES (30 points)\n\n**Test against held-out test cases from ground truth:**\n- Test against `held_out_positive` examples\n- Test against `held_out_negative` examples\n\n**Scoring:**\n- Perfect generalization: 30 points\n- For each held-out positive that fails: -5 points\n- For each held-out negative that incorrectly matches: -5 points\n- Minimum: 0 points\n\n## 3. REGEX VALIDITY (15 points)\n\n**Check if regex is executable:**\n- Syntactically valid regex: 15 points\n- Invalid syntax or cannot be compiled: 0 points\n- Deduct 5 points if missing anchors (^ and $) when ground truth has them\n\n## 4. FORMAT COMPLIANCE (10 points)\n\n**Required fields present and correct type:**\n- `challenge_id` matches input: 2 points\n- `regex` is a string: 2 points\n- `explanation` is a non-empty string: 2 points\n- `confidence` is one of [high, medium, low]: 2 points\n- `test_results` object with all 4 numeric fields: 2 points\n\n## 5. CONCISENESS (5 points)\n\n**Evaluate regex complexity:**\n- Compare length to ground truth regex\n- If within 50% of ground truth length: 5 points\n- If 50-100% longer: 3 points\n- If 100-200% longer: 1 point\n- If >200% longer (likely overfitting): 0 points\n- Exception: If regex is just OR-ing all positive examples, automatic 0 points\n\n# COMPARISON PROCESS\n\n1. Load the candidate regex and ground truth regex\n2. Execute both against all test cases (provided + held-out)\n3. Compare results\n4. Check for overfitting patterns (e.g., `(example1|example2|example3)`)\n5. Validate syntax by attempting to compile the regex\n6. Calculate scores per criteria above\n7. Sum total score (max 100 points)\n\n# OVERFITTING DETECTION\n\nA regex is considered overfitted if:\n- It uses alternation to list out specific examples: `^(555-123-4567|123-456-7890|...)$`\n- It's significantly longer than necessary\n- It fails held-out test cases despite passing provided examples\n\n**Penalty for detected overfitting:** -20 points from total score\n\n# OUTPUT FORMAT\n\nProvide your evaluation as JSON:\n\n```json\n{\n  \"challenge_id\": \"REGEX-XXX\",\n  \"scores\": {\n    \"correctness_provided\": 40,\n    \"generalization_held_out\": 30,\n    \"validity\": 15,\n    \"format_compliance\": 10,\n    \"conciseness\": 5,\n    \"overfitting_penalty\": 0,\n    \"total\": 100\n  },\n  \"test_results\": {\n    \"provided_positive_passed\": 5,\n    \"provided_positive_total\": 5,\n    \"provided_negative_passed\": 5,\n    \"provided_negative_total\": 5,\n    \"held_out_positive_passed\": 2,\n    \"held_out_positive_total\": 2,\n    \"held_out_negative_passed\": 2,\n    \"held_out_negative_total\": 2\n  },\n  \"violations\": [\n    {\n      \"type\": \"FAILED_POSITIVE_MATCH\",\n      \"severity\": \"CRITICAL\",\n      \"description\": \"Regex failed to match positive example: '555-123-4567'\",\n      \"penalty\": 4\n    }\n  ],\n  \"regex_comparison\": {\n    \"candidate_regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n    \"ground_truth_regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n    \"candidate_length\": 20,\n    \"ground_truth_length\": 20,\n    \"length_ratio\": 1.0,\n    \"is_overfitted\": false\n  },\n  \"overall_assessment\": \"Brief summary of performance\"\n}\n```\n\n# GROUND TRUTH DATA\n\nYou will be provided with:\n1. The original challenge (positive/negative examples)\n2. The ground truth solution (correct regex + held-out test cases)\n3. The candidate output to evaluate\n\nExecute the evaluation systematically and provide detailed scoring.",
    "rubric": {
      "critical_requirements": [
        {
          "name": "matches_all_positive_examples",
          "description": "The generated regex must match 100% of provided positive examples",
          "derived_from": "Core task requirement - regex must have perfect recall on training set",
          "penalty_per_violation": 4
        },
        {
          "name": "rejects_all_negative_examples",
          "description": "The generated regex must reject 100% of provided negative examples",
          "derived_from": "Core task requirement - regex must have perfect precision on training set",
          "penalty_per_violation": 4
        },
        {
          "name": "generalizes_to_held_out_positive",
          "description": "The regex must match held-out positive examples not shown during generation",
          "derived_from": "Ground truth includes held_out_positive field for generalization testing",
          "penalty_per_violation": 5
        },
        {
          "name": "generalizes_to_held_out_negative",
          "description": "The regex must reject held-out negative examples not shown during generation",
          "derived_from": "Ground truth includes held_out_negative field for generalization testing",
          "penalty_per_violation": 5
        },
        {
          "name": "syntactically_valid_regex",
          "description": "The regex must be valid and executable in standard regex engines",
          "derived_from": "Task requirement for working regular expression",
          "penalty_per_violation": 15
        }
      ],
      "compliance_checks": [
        {
          "check": "output_format_valid_json",
          "condition": "Output is not valid JSON or missing required fields",
          "severity": "CRITICAL",
          "penalty": 10
        },
        {
          "check": "challenge_id_matches",
          "condition": "challenge_id in output does not match input challenge_id",
          "severity": "HIGH",
          "penalty": 2
        },
        {
          "check": "regex_field_present",
          "condition": "regex field is missing or not a string",
          "severity": "CRITICAL",
          "penalty": 15
        },
        {
          "check": "explanation_present",
          "condition": "explanation field is missing or empty",
          "severity": "MEDIUM",
          "penalty": 2
        },
        {
          "check": "confidence_valid",
          "condition": "confidence is not one of: high, medium, low",
          "severity": "MEDIUM",
          "penalty": 2
        },
        {
          "check": "test_results_complete",
          "condition": "test_results object missing or lacks required numeric fields",
          "severity": "MEDIUM",
          "penalty": 2
        },
        {
          "check": "anchors_present",
          "condition": "Regex missing ^ or $ anchors when ground truth includes them",
          "severity": "HIGH",
          "penalty": 5
        },
        {
          "check": "overfitting_detected",
          "condition": "Regex appears to be overfitted (e.g., OR-ing specific examples)",
          "severity": "CRITICAL",
          "penalty": 20
        },
        {
          "check": "excessive_length",
          "condition": "Regex is more than 200% longer than ground truth solution",
          "severity": "MEDIUM",
          "penalty": 5
        }
      ],
      "weights": {
        "accuracy": 40,
        "format": 10,
        "compliance": 50
      },
      "scoring_instructions": "Calculate total score out of 100 points:\n\n1. CORRECTNESS ON PROVIDED EXAMPLES (40 points max):\n   - Start with 40 points\n   - Subtract 4 points for each positive example that fails to match\n   - Subtract 4 points for each negative example that incorrectly matches\n   - Floor at 0 points\n\n2. GENERALIZATION TO HELD-OUT EXAMPLES (30 points max):\n   - Start with 30 points\n   - Subtract 5 points for each held-out positive that fails\n   - Subtract 5 points for each held-out negative that incorrectly matches\n   - Floor at 0 points\n\n3. REGEX VALIDITY (15 points max):\n   - 15 points if regex compiles and executes\n   - 0 points if syntax error\n   - Subtract 5 points if missing required anchors\n\n4. FORMAT COMPLIANCE (10 points max):\n   - 2 points for correct challenge_id\n   - 2 points for regex field present\n   - 2 points for explanation present\n   - 2 points for valid confidence value\n   - 2 points for complete test_results object\n\n5. CONCISENESS (5 points max):\n   - 5 points if within 50% of ground truth length\n   - 3 points if 50-100% longer\n   - 1 point if 100-200% longer\n   - 0 points if >200% longer\n   - 0 points if overfitting detected\n\n6. APPLY PENALTIES:\n   - Subtract 20 points if overfitting detected\n   - Apply any other compliance check penalties\n\n7. FINAL SCORE:\n   - Sum all component scores\n   - Subtract all penalties\n   - Floor at 0, cap at 100\n\nProvide detailed breakdown showing each component score and all penalties applied."
    }
  },
  "results": [
    {
      "model_name": "anthropic/claude-sonnet-4",
      "task_name": "regex_pattern_generation_from_examples",
      "output": "/* chunk 1 */\n```json\n{\n  \"challenge_id\": \"REGEX-001\",\n  \"regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n  \"explanation\": \"Matches exactly three digits, followed by a dash, then three digits, another dash, and four digits - standard US phone number format\",\n  \"confidence\": \"high\",\n  \"test_results\": {\n    \"positive_matches\": 5,\n    \"positive_total\": 5,\n    \"negative_rejected\": 6,\n    \"negative_total\": 6\n  }\n}\n```",
      "input_tokens": 2964,
      "output_tokens": 140,
      "total_tokens": 3104,
      "cost_usd": 0.011,
      "billed_cost_usd": 0.010992,
      "latency_ms": 3147.2038000356406,
      "timestamp": "2025-12-31 13:27:58.955341",
      "generation_id": "gen-1767209275-dWpSiBABaoD5rOd7V6hE",
      "provider": null,
      "status": "success",
      "error": null
    },
    {
      "model_name": "openai/gpt-4o",
      "task_name": "regex_pattern_generation_from_examples",
      "output": "[\n  {\n    \"challenge_id\": \"REGEX-001\",\n    \"regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n    \"explanation\": \"Three digits, dash, three digits, dash, four digits - standard US phone format\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 5,\n      \"positive_total\": 5,\n      \"negative_rejected\": 6,\n      \"negative_total\": 6\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-002\",\n    \"regex\": \"^(?!.*[._]{2})[a-zA-Z0-9]+([._][a-zA-Z0-9]+)*$\",\n    \"explanation\": \"Letters, numbers, dots, and underscores. Cannot start/end with dot or underscore, no consecutive dots\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 6,\n      \"positive_total\": 6,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-003\",\n    \"regex\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)$\",\n    \"explanation\": \"Three numeric components separated by dots, no leading zeros except single 0\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 6,\n      \"positive_total\": 6,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-004\",\n    \"regex\": \"^#[0-9a-fA-F]{6}$\",\n    \"explanation\": \"Hash followed by exactly 6 hexadecimal digits\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 6,\n      \"positive_total\": 6,\n      \"negative_rejected\": 7,\n      \"negative_total\": 7\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-005\",\n    \"regex\": \"^(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d{2}|[1-9]?\\\\d)){3}$\",\n    \"explanation\": \"Four octets each ranging from 0 to 255, no leading zeros except single 0\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 6,\n      \"positive_total\": 6,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-006\",\n    \"regex\": \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[!@#$%^&*])[A-Za-z\\\\d!@#$%^&*]{8,}$\",\n    \"explanation\": \"Minimum 8 characters, at least 1 uppercase, 1 lowercase, 1 digit, and 1 special character\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 5,\n      \"positive_total\": 5,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-007\",\n    \"regex\": \"^(19|20)\\\\d{2}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\\\d|3[01])$\",\n    \"explanation\": \"ISO date format YYYY-MM-DD with valid month (01-12) and day (01-31)\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 5,\n      \"positive_total\": 5,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-008\",\n    \"regex\": \"^[A-Za-z_][A-Za-z0-9_]*$\",\n    \"explanation\": \"Starts with a letter or underscore, followed by alphanumeric characters or underscores\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 7,\n      \"positive_total\": 7,\n      \"negative_rejected\": 7,\n      \"negative_total\": 7\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-009\",\n    \"regex\": \"^\\\\*{4}-\\\\*{4}-\\\\*{4}-\\\\d{4}$\",\n    \"explanation\": \"First three groups masked with asterisks, last 4 digits visible\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 4,\n      \"positive_total\": 4,\n      \"negative_rejected\": 6,\n      \"negative_total\": 6\n    }\n  },\n  {\n    \"challenge_id\": \"REGEX-010\",\n    \"regex\": \"^(?:[01]\\\\d|2[0-3]):[0-5]\\\\d$\",\n    \"explanation\": \"Valid 24-hour time format with hours 00-23 and minutes 00-59\",\n    \"confidence\": \"high\",\n    \"test_results\": {\n      \"positive_matches\": 6,\n      \"positive_total\": 6,\n      \"negative_rejected\": 8,\n      \"negative_total\": 8\n    }\n  }\n]",
      "input_tokens": 2518,
      "output_tokens": 1223,
      "total_tokens": 3741,
      "cost_usd": 0.0185,
      "billed_cost_usd": 0.018525,
      "latency_ms": 16299.961499986239,
      "timestamp": "2025-12-31 13:28:12.121180",
      "generation_id": "gen-1767209275-qTMYwnsWD4X8hHXyct2L",
      "provider": null,
      "status": "success",
      "error": null
    }
  ],
  "scores": [
    {
      "model_evaluated": "anthropic/claude-sonnet-4",
      "accuracy_score": 0,
      "format_score": 0,
      "compliance_score": 0,
      "overall_score": 0,
      "violations": [],
      "reasoning": "Evaluation complete.",
      "timestamp": "2025-12-31 13:28:19.760070"
    },
    {
      "model_evaluated": "openai/gpt-4o",
      "accuracy_score": 95,
      "format_score": 100,
      "compliance_score": 90,
      "overall_score": 94,
      "violations": [
        "MEDIUM: Regex '^(?!.*[._]{2})[a-zA-Z0-9]+([._][a-zA-Z0-9]+)*$' fails to match held-out positive 'x' (single character) due to pattern requiring at least 2 characters in practice",
        "MEDIUM: Regex '^(19|20)\\d{2}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$' restricts years to 1900-2099, while ground truth '^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$' allows any 4-digit year"
      ],
      "reasoning": "Evaluated 10 regex challenges. CORRECTNESS: All 10 regexes correctly matched 100% of provided positive and negative examples (40/40 points per challenge). GENERALIZATION: 9 of 10 challenges showed perfect generalization to held-out test cases. REGEX-002 has a subtle issue where the pattern '^(?!.*[._]{2})[a-zA-Z0-9]+([._][a-zA-Z0-9]+)*$' requires at least one alphanumeric character followed by optional groups, which may fail single-character matches like 'x' depending on interpretation, though the ground truth '^[a-zA-Z0-9]([a-zA-Z0-9._]*[a-zA-Z0-9])?$' explicitly handles single characters. REGEX-007 over-constrains years to 19xx-20xx while ground truth accepts any 4-digit year, but this doesn't violate held-out tests. VALIDITY: All 10 regexes are syntactically valid with proper anchors (15/15 points). FORMAT: All outputs contain required fields with correct types and values (10/10 points). CONCISENESS: All regexes are appropriately concise, within reasonable length of ground truth solutions, no overfitting detected (5/5 points). Total deductions: 5 points for REGEX-002 generalization concern. Overall: 95/100 accuracy, 100/100 format, 90/100 compliance (one potential generalization issue), weighted overall 94/100.",
      "timestamp": "2025-12-31 13:28:34.265238"
    }
  ],
  "statistics": {
    "total_cost": 0.03,
    "total_tokens": 6845,
    "total_input_tokens": 5482,
    "total_output_tokens": 1363,
    "total_evaluations": 2,
    "avg_cost_per_eval": 0.015,
    "avg_tokens_per_eval": 3422,
    "cost_by_model": {
      "anthropic/claude-sonnet-4": {
        "cost": 0.011,
        "input_tokens": 2964,
        "output_tokens": 140,
        "evaluations": 1
      },
      "openai/gpt-4o": {
        "cost": 0.0185,
        "input_tokens": 2518,
        "output_tokens": 1223,
        "evaluations": 1
      }
    }
  }
}