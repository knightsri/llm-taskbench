{
  "analysis": {
    "transformation_type": "Pattern recognition and regex generation - the LLM must analyze positive and negative string examples to infer the underlying pattern and express it as a valid regular expression",
    "key_fields": [
      "challenge_id",
      "regex",
      "explanation",
      "confidence",
      "test_results"
    ],
    "quality_indicators": [
      "Regex matches ALL positive examples (100% recall on training set)",
      "Regex rejects ALL negative examples (100% precision on training set)",
      "Regex generalizes to held-out test cases not shown to model",
      "Regex is syntactically valid and executable",
      "Regex is reasonably concise (not just OR-ing all examples)",
      "Explanation accurately describes what the pattern matches"
    ],
    "comparison_strategy": "Execute the generated regex against all positive/negative examples (both provided and held-out). Calculate match rates. Validate syntax. Compare regex complexity. Check for overfitting patterns like excessive alternation."
  },
  "task_prompt": "You are a regex pattern generation expert. Your task is to analyze sets of positive and negative string examples and generate a regular expression that correctly matches the pattern.\n\n# INSTRUCTIONS\n\n1. Carefully examine the positive examples to identify what they have in common\n2. Examine the negative examples to understand what should NOT match\n3. Generate a regular expression that:\n   - Matches ALL positive examples\n   - Rejects ALL negative examples\n   - Is concise and generalizable (avoid overfitting)\n   - Uses standard regex syntax (PCRE or JavaScript compatible)\n4. Include anchors (^ and $) to match the entire string\n5. Provide a clear explanation of what your pattern matches\n6. Test your regex mentally against all examples before finalizing\n\n# INPUT FORMAT\n\nYou will receive a challenge with:\n- `challenge_id`: Unique identifier\n- `name`: Description of the pattern type\n- `difficulty`: Complexity level\n- `positive_examples`: Strings that MUST match your regex\n- `negative_examples`: Strings that must NOT match your regex\n- `hint`: Optional guidance about the pattern\n\n# OUTPUT FORMAT\n\nRespond with valid JSON matching this exact schema:\n\n```json\n{\n  \"challenge_id\": \"REGEX-XXX\",\n  \"regex\": \"^your_pattern_here$\",\n  \"explanation\": \"Clear description of what the pattern matches and key constraints\",\n  \"confidence\": \"high|medium|low\",\n  \"test_results\": {\n    \"positive_matches\": <number of positive examples your regex matches>,\n    \"positive_total\": <total positive examples>,\n    \"negative_rejected\": <number of negative examples your regex correctly rejects>,\n    \"negative_total\": <total negative examples>\n  }\n}\n```\n\n# IMPORTANT GUIDELINES\n\n- Your regex should generalize beyond the specific examples (think about the underlying rule)\n- Avoid simply OR-ing all positive examples together\n- Consider edge cases and boundary conditions\n- Use character classes, quantifiers, and grouping appropriately\n- Escape special regex characters properly\n- Test your regex against ALL provided examples\n- Set confidence based on pattern complexity and your certainty\n\n# EXAMPLE\n\nInput:\n```json\n{\n  \"challenge_id\": \"REGEX-001\",\n  \"positive_examples\": [\"555-123-4567\", \"123-456-7890\"],\n  \"negative_examples\": [\"55-123-4567\", \"555.123.4567\"]\n}\n```\n\nOutput:\n```json\n{\n  \"challenge_id\": \"REGEX-001\",\n  \"regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n  \"explanation\": \"Three digits, dash, three digits, dash, four digits - standard US phone format\",\n  \"confidence\": \"high\",\n  \"test_results\": {\n    \"positive_matches\": 2,\n    \"positive_total\": 2,\n    \"negative_rejected\": 2,\n    \"negative_total\": 2\n  }\n}\n```\n\nNow process the challenge and generate your regex pattern.",
  "judge_prompt": "You are evaluating a regex pattern generation task. The model was given positive and negative string examples and asked to generate a regular expression that matches all positive examples and rejects all negative examples.\n\n# EVALUATION CRITERIA\n\n## 1. CORRECTNESS ON PROVIDED EXAMPLES (40 points)\n\n**Test the regex against all provided examples:**\n- Execute the regex against each positive example\n- Execute the regex against each negative example\n- Calculate match rates\n\n**Scoring:**\n- Perfect match (100% positive matched, 100% negative rejected): 40 points\n- For each positive example that fails to match: -4 points\n- For each negative example that incorrectly matches: -4 points\n- Minimum: 0 points\n\n## 2. GENERALIZATION TO HELD-OUT EXAMPLES (30 points)\n\n**Test against held-out test cases from ground truth:**\n- Test against `held_out_positive` examples\n- Test against `held_out_negative` examples\n\n**Scoring:**\n- Perfect generalization: 30 points\n- For each held-out positive that fails: -5 points\n- For each held-out negative that incorrectly matches: -5 points\n- Minimum: 0 points\n\n## 3. REGEX VALIDITY (15 points)\n\n**Check if regex is executable:**\n- Syntactically valid regex: 15 points\n- Invalid syntax or cannot be compiled: 0 points\n- Deduct 5 points if missing anchors (^ and $) when ground truth has them\n\n## 4. FORMAT COMPLIANCE (10 points)\n\n**Required fields present and correct type:**\n- `challenge_id` matches input: 2 points\n- `regex` is a string: 2 points\n- `explanation` is a non-empty string: 2 points\n- `confidence` is one of [high, medium, low]: 2 points\n- `test_results` object with all 4 numeric fields: 2 points\n\n## 5. CONCISENESS (5 points)\n\n**Evaluate regex complexity:**\n- Compare length to ground truth regex\n- If within 50% of ground truth length: 5 points\n- If 50-100% longer: 3 points\n- If 100-200% longer: 1 point\n- If >200% longer (likely overfitting): 0 points\n- Exception: If regex is just OR-ing all positive examples, automatic 0 points\n\n# COMPARISON PROCESS\n\n1. Load the candidate regex and ground truth regex\n2. Execute both against all test cases (provided + held-out)\n3. Compare results\n4. Check for overfitting patterns (e.g., `(example1|example2|example3)`)\n5. Validate syntax by attempting to compile the regex\n6. Calculate scores per criteria above\n7. Sum total score (max 100 points)\n\n# OVERFITTING DETECTION\n\nA regex is considered overfitted if:\n- It uses alternation to list out specific examples: `^(555-123-4567|123-456-7890|...)$`\n- It's significantly longer than necessary\n- It fails held-out test cases despite passing provided examples\n\n**Penalty for detected overfitting:** -20 points from total score\n\n# OUTPUT FORMAT\n\nProvide your evaluation as JSON:\n\n```json\n{\n  \"challenge_id\": \"REGEX-XXX\",\n  \"scores\": {\n    \"correctness_provided\": 40,\n    \"generalization_held_out\": 30,\n    \"validity\": 15,\n    \"format_compliance\": 10,\n    \"conciseness\": 5,\n    \"overfitting_penalty\": 0,\n    \"total\": 100\n  },\n  \"test_results\": {\n    \"provided_positive_passed\": 5,\n    \"provided_positive_total\": 5,\n    \"provided_negative_passed\": 5,\n    \"provided_negative_total\": 5,\n    \"held_out_positive_passed\": 2,\n    \"held_out_positive_total\": 2,\n    \"held_out_negative_passed\": 2,\n    \"held_out_negative_total\": 2\n  },\n  \"violations\": [\n    {\n      \"type\": \"FAILED_POSITIVE_MATCH\",\n      \"severity\": \"CRITICAL\",\n      \"description\": \"Regex failed to match positive example: '555-123-4567'\",\n      \"penalty\": 4\n    }\n  ],\n  \"regex_comparison\": {\n    \"candidate_regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n    \"ground_truth_regex\": \"^\\\\d{3}-\\\\d{3}-\\\\d{4}$\",\n    \"candidate_length\": 20,\n    \"ground_truth_length\": 20,\n    \"length_ratio\": 1.0,\n    \"is_overfitted\": false\n  },\n  \"overall_assessment\": \"Brief summary of performance\"\n}\n```\n\n# GROUND TRUTH DATA\n\nYou will be provided with:\n1. The original challenge (positive/negative examples)\n2. The ground truth solution (correct regex + held-out test cases)\n3. The candidate output to evaluate\n\nExecute the evaluation systematically and provide detailed scoring.",
  "rubric": {
    "critical_requirements": [
      {
        "name": "matches_all_positive_examples",
        "description": "The generated regex must match 100% of provided positive examples",
        "derived_from": "Core task requirement - regex must have perfect recall on training set",
        "penalty_per_violation": 4
      },
      {
        "name": "rejects_all_negative_examples",
        "description": "The generated regex must reject 100% of provided negative examples",
        "derived_from": "Core task requirement - regex must have perfect precision on training set",
        "penalty_per_violation": 4
      },
      {
        "name": "generalizes_to_held_out_positive",
        "description": "The regex must match held-out positive examples not shown during generation",
        "derived_from": "Ground truth includes held_out_positive field for generalization testing",
        "penalty_per_violation": 5
      },
      {
        "name": "generalizes_to_held_out_negative",
        "description": "The regex must reject held-out negative examples not shown during generation",
        "derived_from": "Ground truth includes held_out_negative field for generalization testing",
        "penalty_per_violation": 5
      },
      {
        "name": "syntactically_valid_regex",
        "description": "The regex must be valid and executable in standard regex engines",
        "derived_from": "Task requirement for working regular expression",
        "penalty_per_violation": 15
      }
    ],
    "compliance_checks": [
      {
        "check": "output_format_valid_json",
        "condition": "Output is not valid JSON or missing required fields",
        "severity": "CRITICAL",
        "penalty": 10
      },
      {
        "check": "challenge_id_matches",
        "condition": "challenge_id in output does not match input challenge_id",
        "severity": "HIGH",
        "penalty": 2
      },
      {
        "check": "regex_field_present",
        "condition": "regex field is missing or not a string",
        "severity": "CRITICAL",
        "penalty": 15
      },
      {
        "check": "explanation_present",
        "condition": "explanation field is missing or empty",
        "severity": "MEDIUM",
        "penalty": 2
      },
      {
        "check": "confidence_valid",
        "condition": "confidence is not one of: high, medium, low",
        "severity": "MEDIUM",
        "penalty": 2
      },
      {
        "check": "test_results_complete",
        "condition": "test_results object missing or lacks required numeric fields",
        "severity": "MEDIUM",
        "penalty": 2
      },
      {
        "check": "anchors_present",
        "condition": "Regex missing ^ or $ anchors when ground truth includes them",
        "severity": "HIGH",
        "penalty": 5
      },
      {
        "check": "overfitting_detected",
        "condition": "Regex appears to be overfitted (e.g., OR-ing specific examples)",
        "severity": "CRITICAL",
        "penalty": 20
      },
      {
        "check": "excessive_length",
        "condition": "Regex is more than 200% longer than ground truth solution",
        "severity": "MEDIUM",
        "penalty": 5
      }
    ],
    "weights": {
      "accuracy": 40,
      "format": 10,
      "compliance": 50
    },
    "scoring_instructions": "Calculate total score out of 100 points:\n\n1. CORRECTNESS ON PROVIDED EXAMPLES (40 points max):\n   - Start with 40 points\n   - Subtract 4 points for each positive example that fails to match\n   - Subtract 4 points for each negative example that incorrectly matches\n   - Floor at 0 points\n\n2. GENERALIZATION TO HELD-OUT EXAMPLES (30 points max):\n   - Start with 30 points\n   - Subtract 5 points for each held-out positive that fails\n   - Subtract 5 points for each held-out negative that incorrectly matches\n   - Floor at 0 points\n\n3. REGEX VALIDITY (15 points max):\n   - 15 points if regex compiles and executes\n   - 0 points if syntax error\n   - Subtract 5 points if missing required anchors\n\n4. FORMAT COMPLIANCE (10 points max):\n   - 2 points for correct challenge_id\n   - 2 points for regex field present\n   - 2 points for explanation present\n   - 2 points for valid confidence value\n   - 2 points for complete test_results object\n\n5. CONCISENESS (5 points max):\n   - 5 points if within 50% of ground truth length\n   - 3 points if 50-100% longer\n   - 1 point if 100-200% longer\n   - 0 points if >200% longer\n   - 0 points if overfitting detected\n\n6. APPLY PENALTIES:\n   - Subtract 20 points if overfitting detected\n   - Apply any other compliance check penalties\n\n7. FINAL SCORE:\n   - Sum all component scores\n   - Subtract all penalties\n   - Floor at 0, cap at 100\n\nProvide detailed breakdown showing each component score and all penalties applied."
  }
}